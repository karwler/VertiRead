#version 450

layout(constant_id = 0) const bool orderRgb = true;
layout(local_size_x = 32) in;

layout(push_constant) uniform PushData {
	uint offset;
} psData;

layout(set = 0, binding = 0) readonly buffer InputData {
	uint pixels[];
} inData;

layout(set = 0, binding = 1, rgba8) writeonly uniform image2D img;

#define storeColor(id, size, r, g, b) \
	imageStore(img, ivec2((id) % size.x, (id) / size.x), vec4(vec3((r), (g), (b)) / 255.0, 1.0))

void main() {
	uint cid = (gl_WorkGroupID.x + psData.offset) * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
	uint iid = cid * 3;
	uint oid = cid * 4;
	ivec2 size = imageSize(img);
	uint len = size.x * size.y;

	uint p0, p1, p2;
	if (oid < len) {
		p0 = inData.pixels[iid];
		if (orderRgb)
			storeColor(oid, size, p0 & 0xFF, (p0 >> 8) & 0xFF, (p0 >> 16) & 0xFF);
		else
			storeColor(oid, size, (p0 >> 16) & 0xFF, (p0 >> 8) & 0xFF, p0 & 0xFF);
	}
	if (oid + 1 < len) {
		p1 = inData.pixels[iid + 1];
		if (orderRgb)
			storeColor(oid + 1, size, p0 >> 24, p1 & 0xFF, (p1 >> 8) & 0xFF);
		else
			storeColor(oid + 1, size, (p1 >> 8) & 0xFF, p1 & 0xFF, p0 >> 24);
	}
	if (oid + 2 < len) {
		p2 = inData.pixels[iid + 2];
		if (orderRgb)
			storeColor(oid + 2, size, (p1 >> 16) & 0xFF, p1 >> 24, p2 & 0xFF);
		else
			storeColor(oid + 2, size, p2 & 0xFF, p1 >> 24, (p1 >> 16) & 0xFF);
	}
	if (oid + 3 < len) {
		if (orderRgb)
			storeColor(oid + 3, size, (p2 >> 8) & 0xFF, (p2 >> 16) & 0xFF, p2 >> 24);
		else
			storeColor(oid + 3, size, p2 >> 24, (p2 >> 16) & 0xFF, (p2 >> 8) & 0xFF);
	}
}
